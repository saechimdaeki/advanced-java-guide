### wait(), notify() 설명

- Object.wait()
  - 현재 스레드가 가진 락을 반납하고 대기(waiting)한다
  - 현재 스레드를 대기 상태로 전환한다. 이 메소드는 현재 스레드가 `synchronized`블록이나 메소드 락을 소유
    
    하고 있을 때만 호출할 수 있다. 호출한 스레드는 락을 반납하고, 다른 스레드가 해당 락을 획득할 수 있도록 한다

    이렇게 대기 상태로 전환된 스레드는 다른 스레드가 notify() 또는 notifyAll()을 호출할 때까지 대기 상태 유지
- Object.notify()
  - 대기 중인 스레드 중 하나를 깨운다
  - 이 메서드는 `synchronized` 블록이나 메서드에서 호출되어야 한다. 깨운 스레드는 락을 다시 획득할 기회를 얻게 된다

    만약 대기 중인 스레드가 여러 개라면, 그 중 하나만이 깨워지게 된다
- Object.notifyAll()
  - 대기 중인 모든 스레드를 깨운다
  - 이 메소드 역시 `synchronized`블록이나 메서드에서 호출되어야 하며, 모든 대기 중인 스레드가 락을 획득할 수 있는 기회를 얻게 된다

    이 방법은 모든 스레드를 꺠워야 할 필요가 있는 경우에 유용하다

### Object - wait, notify - 한계

Object.wait(), Object.notify() 방식은 스레드 대기 집합하나에 생산자, 소비자 스레드를 모두 관리한다

그리고 notify() 를 호출할 때 임의의 스레드가 선택된다. 따라서 큐에 데이터가 없는 상황에 소비자가 같은 소비자를 깨우는 비효율이 발생할 수 있다

또는 큐에 데이터가 가득 차 있는데 생산자가 같은 생산자를 깨우는 비효율도 발생할 수 있다

스레드 기아 (thread starvation) 문제가 발생할 수 있다

- notify() 의 또 다른 문제점으로는 어떤 스레드가 깨어날 지 알 수 없기 때문에 발생할 수 있는 스레드 기아 문제

### 해결방안

- 핵심은 생산자 스레드는 데이터를 생성하고, 대기 중인 소비자 스레드에게 알려주어야 한다.
- 반대로 소비자 스레드는 데이터를 소비하고 대기중인 생산자 스레드에 알려주면 된다
- 즉, 생산자 스레드가 대기하는 대기 집합과, 소비자 스레드가 대기하는 대기집합을 둘로 나누면 된다
