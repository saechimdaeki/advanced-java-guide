### wait(), notify() 설명

- Object.wait()
  - 현재 스레드가 가진 락을 반납하고 대기(waiting)한다
  - 현재 스레드를 대기 상태로 전환한다. 이 메소드는 현재 스레드가 `synchronized`블록이나 메소드 락을 소유
    
    하고 있을 때만 호출할 수 있다. 호출한 스레드는 락을 반납하고, 다른 스레드가 해당 락을 획득할 수 있도록 한다

    이렇게 대기 상태로 전환된 스레드는 다른 스레드가 notify() 또는 notifyAll()을 호출할 때까지 대기 상태 유지
- Object.notify()
  - 대기 중인 스레드 중 하나를 깨운다
  - 이 메서드는 `synchronized` 블록이나 메서드에서 호출되어야 한다. 깨운 스레드는 락을 다시 획득할 기회를 얻게 된다

    만약 대기 중인 스레드가 여러 개라면, 그 중 하나만이 깨워지게 된다
- Object.notifyAll()
  - 대기 중인 모든 스레드를 깨운다
  - 이 메소드 역시 `synchronized`블록이나 메서드에서 호출되어야 하며, 모든 대기 중인 스레드가 락을 획득할 수 있는 기회를 얻게 된다

    이 방법은 모든 스레드를 꺠워야 할 필요가 있는 경우에 유용하다

### Object - wait, notify - 한계

Object.wait(), Object.notify() 방식은 스레드 대기 집합하나에 생산자, 소비자 스레드를 모두 관리한다

그리고 notify() 를 호출할 때 임의의 스레드가 선택된다. 따라서 큐에 데이터가 없는 상황에 소비자가 같은 소비자를 깨우는 비효율이 발생할 수 있다

또는 큐에 데이터가 가득 차 있는데 생산자가 같은 생산자를 깨우는 비효율도 발생할 수 있다

스레드 기아 (thread starvation) 문제가 발생할 수 있다

- notify() 의 또 다른 문제점으로는 어떤 스레드가 깨어날 지 알 수 없기 때문에 발생할 수 있는 스레드 기아 문제

### 해결방안

- 핵심은 생산자 스레드는 데이터를 생성하고, 대기 중인 소비자 스레드에게 알려주어야 한다.
- 반대로 소비자 스레드는 데이터를 소비하고 대기중인 생산자 스레드에 알려주면 된다
- 즉, 생산자 스레드가 대기하는 대기 집합과, 소비자 스레드가 대기하는 대기집합을 둘로 나누면 된다

Condition은 ReentrantLock을 사용하는 스레드가 대기하는 스레드 대기 공간이며

lock.newCondition() 메소드를 호출하면 스레드 대기 공간이 만들어진다. Lock(ReentrantLock)의 스레드 대기 공간은 이렇게 만들 수 있다

`condition.await()`
- Object.wait()와 유사한 기능이다. 지정한 condition에 현재 스레드를 대기상태로 보관한다
- 이때 ReentrantLock에서 획득한 락을 반납하고 대기 상태로 condition에 보관된다

`condition.signal()`
- Object.notify()와 유사한 기능이다. 지정한 condition에 대기 중인 스레드 중 하나를 깨운다. 깨어난 스레드는 condition에서 빠져나온다

#### Object.notify() vs Condition.signal()
- Object.notify()
  - 대기 중인 스레드 중 임의의 하나를 선택해서 깨운다. 스레드가 깨어나는 순서는 정의되어 있지 않으며, JVM구현에 따라 다르다
  - 보통은 먼저 들어온 스레드가 먼저 수행되지만 구현에 따라 다를 수 있다
  - synchronized 블록 내에서 모니터 락을 가지고 있는 스레드가 호출해야 한다
- Condition.signal()
  - 대기 중인 스레드 중 하나를 깨우며, 일반적으로는 FIFO 순서로 깨운다. 자바 버전과 구현에 따라 달라질 수 있지만 
  - 보통 Condition의 구현은 Queue 구조를 사용하기 때문에 FIFO순서로 꺠움
  - ReentrantLock을 가지고 있는 스레드가 호출해야 한다
